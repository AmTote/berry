diff --git a/vfs.js b/vfs.js
new file mode 100644
--- /dev/null
+++ b/vfs.js
@@ -0,0 +1,104 @@
+const path = require(`path`);
+
+function getPnpApi() {
+  let pnpApi;
+  try {
+    if (process.versions.pnp) {
+      pnpApi = require(`pnpapi`);
+    }
+  } catch (ex) {}
+  return pnpApi;
+}
+
+function resolveVirtual(p) {
+  const pnpapi = getPnpApi();
+  if (pnpapi) {
+    const resolved = pnpapi.resolveVirtual(p);
+    // pnp resolveVirtual will return null for non-virtual path.
+    return resolved == null ? p : resolved;
+  }
+  return p;
+}
+
+function findVirtualPaths(root) {
+  const paths = [];
+  const pnpapi = getPnpApi();
+  if (pnpapi) {
+    for (const locator of pnpapi.getDependencyTreeRoots()) {
+      const pkg = pnpapi.getPackageInformation(locator);
+      for (const [name, referencish] of pkg.packageDependencies) {
+        if (referencish === null) continue;
+        if (referencish.indexOf(`virtual:`) === 0) {
+          const virtualLocator = pnpapi.getLocator(name, referencish);
+          const virtualPkg = pnpapi.getPackageInformation(virtualLocator);
+          if (virtualPkg && virtualPkg.packageLocation.indexOf(root) === 0) {
+            // virtual path fall under root
+            paths.push(virtualPkg.packageLocation);
+          }
+        }
+      }
+    }
+  }
+  return paths;
+}
+
+class VFS {
+  constructor(p, Native) {
+    this.root = path.resolve(p);
+    this.native = Native;
+    this.watchers = [];
+  }
+
+  transpose(rawPath, resolvedPath, p) {
+    const transposePath = rawPath + p.substr(resolvedPath.length);
+    return transposePath;
+  }
+
+  /**
+   * build raw and resolved path mapping
+   * @param {*} root
+   */
+  buildPathMap() {
+    const pathMap = new Map();
+    this.resolvedRoot = resolveVirtual(this.root);
+    pathMap.set(this.resolvedRoot, this.root);
+    if (!path.extname(this.root)) {
+      // find all direct virtual paths for given root.
+      const virtualPaths = findVirtualPaths(this.root);
+      virtualPaths.forEach((virtualPath) => {
+        const resolvedVirtual = resolveVirtual(virtualPath);
+        if (resolvedVirtual.indexOf(this.resolvedRoot) < 0) {
+          pathMap.set(resolvedVirtual, virtualPath);
+        }
+      });
+    }
+    return pathMap;
+  }
+
+  watch(handler) {
+    const pathMap = this.buildPathMap();
+    pathMap.forEach((virtualPath, resolvedPath) => {
+      const watcher = this.native.start(resolvedPath, (p, ...args) => {
+        return handler(this.transpose(virtualPath, resolvedPath, p), ...args);
+      });
+      if (!watcher) throw new Error(`could not watch: ${resolvedPath}`);
+      this.watchers.push(watcher);
+    });
+    return this.watchers;
+  }
+
+  stop() {
+    const results = this.watchers.map((watcher) => {
+      const p = Promise.resolve(watcher);
+      if (watcher) {
+        p.then(this.native.stop);
+      }
+      return p;
+    });
+    this.watchers = [];
+    this.resolvedRoot = undefined;
+    return results[0];
+  }
+}
+
+module.exports = VFS;
